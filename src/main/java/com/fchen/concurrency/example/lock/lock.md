## 锁

&ensp;&ensp;锁是用来控制多个线程访问共享资源的方式。在Java中实现锁的功能有下面两种方式：
* 1.依靠synchronized关键字
* 2.并发包中的Lock接口及其相关的实现类

### 锁的状态
&ensp;&ensp;锁一共有四种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级为轻量级锁后不能降级为偏向锁。这种锁升级但不能降级的策略，目的是为了提高获取锁和释放锁的效率。

&ensp;&ensp;锁的状态，是通过存在Java对象头存储结构中的锁标识位来表明的。

&ensp;&ensp;[Java对象头存储结构]知识详见。

#### 1. 偏向锁
&ensp;&ensp;偏向锁的意思是，这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要在进行同步。偏向锁在Java6和Java7中是默认启用的，但是他在应用线程启动几秒钟之后才激活，如有必要可以
使用JVM的参数来关闭延迟：  -XX:BiasedLockingStartupDelay=0。

&ensp;&ensp;当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，并将对象头中的标志位设置为“01”，偏向模式。以后该线程进入和退出同步块是不需要进行CAS操作来进行加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示该线程已经获取到锁。如果测试失败，则需要再测试一下Mark Word 中偏向锁的标识是否设置为1(表示当前锁是偏向锁)：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

&ensp;&ensp;偏向锁可以提高带有同步但无竞争的程序性能。它同样是带有一个效益权衡的性质的优化，也就是说，它并不一定总是对程序运行有利的，如果程序运行中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的，可以通过JVM的参数关闭偏向锁：-XX:-UseBiasedLocking==false,程序会默认进入轻量级锁状态。


#### 2. 轻量级锁
&ensp;&ensp;当锁是偏向锁的时候，被另一个线程访问，偏向缩就会升级为轻量级锁，其他线程会通过自旋(不放弃CPU的执行时间)的形式尝试获取锁，不会阻塞，提高性能。

**轻量级锁加锁**

&ensp;&ensp;线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后尝试使用CAS将对象头中的Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，并且对象Mark Word 的锁标识位变为"00"，即表示对象处于轻量级锁定的状态;如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。当自旋到一定次数后，该锁膨胀为重量级锁，锁标识的状态值变为"10"，Mark Word 中存贮的就是重量级锁(互斥量)的指针，后面等待锁的线程也要进入阻塞状态。

**轻量级锁解锁**

&ensp;&ensp;轻量级锁解锁时，会使用原子的CAS操作将Displaced Mark Word 替换回对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

#### 3. 重量级锁
&ensp;&ensp;重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，
该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

&ensp;&ensp;重量级锁是通过使用操作系统互斥量实现的锁。

**上述三种锁不同状态的优缺点比较**：

锁 | 优点 | 缺点 | 适用场景
---|---|---|---
偏向锁  | 加锁和解锁不需要额外的消耗|如果线程间存在竞争，会带来额外的锁撤销消耗|只有一个线程访问同步块
轻量级锁| 竞争的线程不会阻塞|得不到锁的线程，自旋消耗CPU资源 | 追求响应时间 <br/>  同步快执行速度非常快
重量级锁| 线程之间不使用自旋，不消耗CPU|线程间相互阻塞，响应时间缓慢 | 追求吞吐量  <br/>  同步快执行时间长

### 自旋锁与自适应自旋
&ensp;&ensp;自旋与自适应自旋是获取锁的方式。主要的实现思想就是，让获取锁的线程等待，不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这项技术就是所谓的自旋锁。

&ensp;&ensp;自旋锁是指尝试获取锁的线程不会立即阻塞，采用循环的方式去尝试获取锁，不需要进行线程间的切换。

**自旋锁的优缺点**：

优点 | 缺点 
---|---
避免了线程切换的开销 | 占用了CPU的资源
锁被占用时间很短，自旋等待效果就很好 | 锁被占用时间长，自旋获取锁的线程就会浪费CPU的资源

解决办法：

&ensp;&ensp;自旋等待的时间必须要有一定的限度，如果自旋超过的限定的次数任然没有成功获取锁，就应当使用传统的方式挂起线程了。自旋次数默认值是10次，用户可以使用参数-XX:PreBlockSpin来更改。

&ensp;&ensp;自适应的自旋锁，意味着自旋的时间不再固定了，而是由前一次在同一个锁上自旋时间及锁的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功的获得过锁，并且持有锁的线程正在运行中，那么虚拟机认为这次自旋也很有可能会再次成功获取，进而将允许自旋等待持续更长的时间，比如100个循环。如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省掉自旋的过程，减少CPU资源的浪费。

### 公平锁与非公平锁
&ensp;&ensp;公平与否是针对获取锁而言的。

&ensp;&ensp;公平锁是指多个线程按照申请锁的顺序来获取锁。非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。

&ensp;&ensp;公平锁保证了锁的获取按照FIFIO原则，而代价是进行大量的线程切换。非公平锁虽然可能造成线程的“饥饿”，但线程的切换减少，保证了更大的吞吐量。

### 独占锁与共享锁

&ensp;&ensp;独占锁就是同一时刻只能有一个线程获取到锁，其他线程只能处于同步容器中等待，只有获取锁的线程释放了锁，其他线程才能获取锁。

&ensp;&ensp;共享锁是指该锁可被多个线程所持有，同一时刻可以有多个线程获取到同步状态。

&ensp;&ensp;在Java中实现独占锁和共享锁可以通过实现AQS中不同的方法来完成。关键在synchronized是独占锁。

### 互斥锁与读写锁
&ensp;&ensp;互斥锁，同一时刻值允许一个线程进行访问，是上面所说的独占锁的具体实现。

&ensp;&ensp;读写锁同一时刻可以允许多个读线程访问，但是在写线程访问时阻塞所有的读线程以及其他的写线程。也就是说: 读写锁维护了一个读锁和一个写锁，来提高并发的性能。

&ensp;&ensp;在读写锁中，读锁是共享锁，写锁是独占锁

### 乐观锁与悲观锁
&ensp;&ensp;悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，
悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。由于悲观锁的特性决定其性能不会很好，因为每次操作都要加锁，操作完成后要释放锁。

&ensp;&ensp;乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。
乐观的认为，不加锁的并发操作是没有事情的。通常我们所讲的CAS操作就是乐观锁。


### 可重入锁
&ensp;&ensp;同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。

&ensp;&ensp;重进入是指任意线程在获取到锁之后能够再次获取锁，而不被阻塞。在Java中synchronized关键字隐式的支持重进入；ReentrantLock()在调用lock()方法时，已经获得锁的线程，能够再次调用Lock()方法获取锁而不被阻塞。

实现锁的重进入，要解决下面两个问题：

* 锁需要识别获取锁的线程是否为当前占据锁的线程，如果是，则再次获取成功。

* 线程重复n次获取了锁，随后在第n次释放该锁后，其他线程才可以获取到该锁。



### 分段锁
&ensp;&ensp;分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。


### 锁消除

### 锁优化



[Java对象头存储结构]:https://mp.weixin.qq.com/s/oqhlqJEc1dQWY8yVqeGfEQ