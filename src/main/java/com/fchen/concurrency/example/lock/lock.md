## 锁

&ensp;&ensp;锁是用来控制多个线程访问共享资源的方式。在Java中实现锁的功能有下面两种方式：
* 1.依靠synchronized关键字
* 2.并发包中的Lock接口及其相关的实现类

### 锁的状态
&ensp;&ensp;锁一共有四种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级为轻量级锁后不能降级为偏向锁。这种锁升级但不能降级的策略，目的是为了提高获取锁和释放锁的效率。

&ensp;&ensp;锁的状态，是通过存在Java对象头存储结构中的锁标识位来表明的。

#### 1.无锁状态
#### 2.偏向锁
&ensp;&ensp;偏向锁的意思是，这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要在进行同步。

&ensp;&ensp;当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，并将对象头中的标志位设置为“01”，偏向模式。以后该线程进入和退出同步块是不需要进行CAS操作来进行加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示该线程已经获取到锁。如果测试失败，则需要在测试一下Mark Word 中偏向锁的标识是否设置为1(表示当前锁是偏向锁)：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。
#### 3.轻量级锁
&ensp;&ensp;当锁是偏向锁的时候，被另一个线程访问，偏向缩就会升级为轻量级锁，其他线程会通过自旋(不放弃CPU的执行时间)的形式尝试获取锁，不会阻塞，提高性能。

#### 4.重量级锁
&ensp;&ensp;重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，
该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

&ensp;&ensp;重量级锁是通过使用操作系统互斥量实现的锁。

上述三种锁不同状态的优缺点比较：
锁 | 优点 | 缺点 | 适用场景
---|---|---|---
偏向锁  | 加锁和解锁不需要额外的消耗|如果线程间存在竞争，会带来额外的锁撤销消耗|只有一个线程访问同步块
轻量级锁| 竞争的线程不会阻塞|得不到锁的线程，自旋消耗CPU资源 | 追求响应时间 
重量级锁| 线程之间不使用自旋，不消耗CPU|线程间相互阻塞，响应时间缓慢 | 追求吞吐量

### 自旋锁与自适应自旋
&ensp;&ensp;自旋与自适应自旋是获取锁的方式。主要的实现思想就是，让获取锁的线程等待，不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这项技术就是所谓的自旋锁。

&ensp;&ensp;自旋锁是指尝试获取锁的线程不会立即阻塞，采用循环的方式去尝试获取锁，不需要进行线程间的切换。

自旋锁的优缺点：
优点 | 缺点 
---|---
避免了线程切换的开销 | 占用了CPU的资源
锁被占用时间很短，自旋等待效果就很好 | 锁被占用时间长，自旋获取锁的线程就会浪费CPU的资源

解决办法：

&ensp;&ensp;自旋等待的时间必须要有一定的限度，如果自旋超过的限定的次数任然没有成功获取锁，就应当使用传统的方式挂起线程了。自旋次数默认值是10次，用户可以使用参数-XX:PreBlockSpin来更改。

&ensp;&ensp;自适应的自旋锁，意味着自旋的时间不在固定了
### 公平锁与非公平锁
&ensp;&ensp;公平锁是指多个线程按照申请锁的顺序来获取锁。非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。

### 独享锁与共享锁
&ensp;&ensp;独享锁是指该锁一次只能被一个线程所持有

&ensp;&ensp;共享锁是指该锁可被多个线程所持有

### 互斥锁与读写锁

### 乐观锁与悲观锁
&ensp;&ensp;悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，
悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。

&ensp;&ensp;乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。
乐观的认为，不加锁的并发操作是没有事情的

### 可重入锁
&ensp;&ensp;同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。

### 分段锁
&ensp;&ensp;分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作


