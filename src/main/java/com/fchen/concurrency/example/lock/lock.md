## 锁

&ensp;&ensp;锁是用来控制多个线程访问共享资源的方式。在Java中实现锁的功能有下面两种方式：
* 1.依靠synchronized关键字
* 2.并发包中的Lock接口及其相关的实现类

### 锁的状态

#### 1.无锁状态
#### 2.偏向锁
&ensp;&ensp;一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
#### 3.轻量级锁
&ensp;&ensp;当锁是偏向锁的时候，被另一个线程访问，偏向缩就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
#### 4.重量级锁
&ensp;&ensp;重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，
该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

### 自旋锁于自适应自旋
&ensp;&ensp;自旋锁是指尝试获取锁的线程不会立即阻塞，采用循环的方式去尝试获取锁，不需要进行线程间的切换。
### 公平锁与非公平锁
&ensp;&ensp;公平锁是指多个线程按照申请锁的顺序来获取锁。非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。

### 独享锁与共享锁
&ensp;&ensp;独享锁是指该锁一次只能被一个线程所持有

&ensp;&ensp;共享锁是指该锁可被多个线程所持有

### 互斥锁与读写锁

### 乐观锁与悲观锁
&ensp;&ensp;悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，
悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。

&ensp;&ensp;乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。
乐观的认为，不加锁的并发操作是没有事情的

### 可重入锁
&ensp;&ensp;同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。

### 分段锁
&ensp;&ensp;分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作


