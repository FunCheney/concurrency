### MySQL 优化思路

#### 1.SQL优化
#### 2.索引优化
#### 3.数据库结构优化
#### 4.InnoDB优化
InnoDB表对应的文件

&ensp;&ensp;.ibd --> 表空间，表空间中保存索引与数据

&ensp;&ensp;.frm --> 表结构
##### InnoDB最佳实践

* 1.基于MySQl查询语句中最常用的字段或字段组合创建主键，如果没有合适的主键也最好使用AUTO_INCRMENT类型的某字段为主键。
* 2.根据需要考虑使用多表查询，将这些表通过外键建立约束关系。
    
      利于写操作。
      对于查询操作就要进行多表查询。就要使用更多内存，更多的CPU使用周期等。 

* 3.关闭autocommit。
* 4.使用事物(START TRANSACTION和COMMIT语句)组合相关的修改或一个整体的工作单元，当然也不应该创建过大的执行单元。
* 5.停止使用LOCk TABLES 语句，InnoDB可以高效的处理来自多个会话的并发读写请求。如果需要再一系列行上获取独占访问权限，可以使用SELECT ... FOR UPDATE 锁定仅需要更新的行。
* 6.启用innodb_file_per_table选项，将各表的数据和索引分别进行存放。
* 7.评估数据和访问模式是否能从InnoDB的表压缩功能中受益(在创建表时使用ROW_FORMAT=COMPRESSED选项)，如果可以，则应该启用压缩功能。

##### InnoDB的索引

索引是在内存中完成比较的，索引本身要装入内存。索引加速查询，降低写入速度。数据更新，索引也要更新。

**主索引(聚集索引)**

&ensp;&ensp;InnoDB的主索引会被辅助索引再次使用到。因为主索引是聚集索引。因此基于辅助索引查找的时候都会还原到主索引上。

&ensp;&ensp;将查询最多的字段，设计成主索引将会大大提高查询速度。

**辅助索引**

&ensp;&ensp;基于辅助索引的查询将会用到两次索引(理由同上)。


**非聚集索引**

&ensp;&ensp;如果我们将索引分开存放，索引是一个文件，数据是一个文件。索引中存放指向数据的指针，这种索引就叫做非聚集索引。

**聚集索引**

&ensp;&ensp;数据与索引存在一起，只要找到索引，就找到对应的数据。将数据存储在索引位置的索引类型就叫做聚集索引。这也就解释了InnoDB的.ibd文件将索引与数据存放在一起的原因。InnoDB使用的是聚集索引。

&ensp;&ensp;一张表只能有一种聚集索引（数据只能按照一种数据存储），其他的辅助索引都是非聚集索引。因此在InnoDB中辅助索引指向的是主索引的(辅助索引-->主索引--数据)。

#### 5.MyISAM优化
MyISAM表有3个文件
&ensp;&ensp;.MYD --> 数据

&ensp;&ensp;.MYI --> 索引

&ensp;&ensp;.frm --> 表结构
#### 6.Memory优化
#### 7.理解查询执行计划
EXPLAN 显示执行计划，语句执行过程中执行的情况。

EXPLAN语句解析:

id：SELECT语句的标识符，一般为数字，表示对应的SELECT语句在原始语句中的位置。没有子查询或者联合的整个查询只有一个SELECT语句，因此其id通常为1.在联合或子查询语句中，内层的SELECT语句通常按它们在原始语句中的次序进行编号。但UNION操作通常最后会有一个id为null的行，因为UNION的结果通常保存在临时表中，而MySQL需要到此临时表中取得结果。

select_type:即SELECT类型，有如下值表示：

SIMPLE:简单查询，即没有私用联合或子查询；

PRIMARY:UNION的最外围的查询或者最先进行的查询；

UNION:相对于PRIMARY，为联合查询的第二个及以后的查询；

DEPENDENT UNION:与UNION相同，但其位于联合子查询中(即UNION查询本身是子查询);

UNION RESULT:UNION的执行结果；

SUBQUERY:非从属子查询，优化器通常认为其只需运行一次。

DEPENDENT SUBQUERY:从属子查询，优化器认为需要为外围的查询每一行运行一次，如用于IN操作符中的子查询；

table：

输出信息所关系到的表的表名，也可能会显示如下格式：

<unionM,n>: id为M和N的查询执行联合查询后的结果；

<derviedN>: id为N的查询执行结果集。

type:

system:表中仅有一行，是const类型的一种特殊；

const:表中至多有一个匹配的行，该行仅在查询开始时读取一次，因此，该行此字段中的值可以被优化器看做是个常量(constant);当基于PRIMARY KEY 或UNIQUE NOT NULL 字段查询，且与某常量进行等值比较时其类型就为const，其执行速度非常快。

eq_ref:类似于const，表中至多有一个匹配的行，但比较的数值不是某常量，而是来自与其他的表；

ref：查询时的索引不是PRIMARY KEY或UNIQUE NOT NULL 导致匹配到的行可能不唯一，或者仅能用到索引的左前缀而非全部时的访问类型；ref可被用于基于索引的字段进行=或<=>操作；

range:带有范围限制的索引扫描，而非全索引扫描，它开始于索引里的某一点，返回匹配那个值的范围行；

fulltext：用于FULLTEXT索引中用于纯文本匹配的方法来检索记录。

index：同全表扫描(ALL),只不过是按照索引的次序进行扫描。其优点是避免了排序，但是要承担按索引次序读取整个表的开销。

ALL：全表扫描的方式查找所需要的行

Extra:







#### 8.缓冲和缓存
缓存表的数据
#### 9.锁优化
数据库锁的粒度(越是细粒度的锁，并发性越强)：

* 表锁
* 页锁
* 行锁

#### 10.MySQl服务器优化

查询缓存(MySQl自己的缓存)，也是键值的格式。键是SELECT语句的Hash码，值是查询的结果。

(语句1)select name from student where age = 30;

(语句2)Select name from student where age = 30;

第一个语句查询缓存的结果，第二个语句是没办法命中的，因为SELECT语句的Hash码不一样。

#### 11.性能评估
#### 12.MySQL优化内幕

&ensp;&ensp;MySql的优化需要再三个不同层次上协调进行：MySQl级别、OS级别和硬件级别。

&ensp;&ensp;MySQL级别的优化包括表优化、查询优化和MySQL服务器配置优化等，而MySQL的各种数据结构又最终作用于OS直至硬件设备，因此还需要了解每种数据结构对os级别的资源的需要并最终导致的CPU/IO操作等，并在此基础上将CPU及IO操作需要尽量降低以提升其效率。


**数据库层面优化思路：**

* 1.正确设定表结构的相关属性，如表字段的字段类型。
    
    &ensp;&ensp;如：字符类型有char与varchar。varchar节省空间，但是char更有利于提高性能。char是定长的，不需要事先计算长度，决定划分的空间，额外新增结束符之类的东西。

* 2.合适的设计表
    
    &ensp;&ensp;如：数据频繁更新，设计成小表而非大表。由于频繁更新需要加锁，设计成多个表后，就会降低锁影响的范围。
* 3.创建合适的索引
    
    &ensp;&ensp;常用的索引有Hash索引与B+tree索引。这两种索引的使用场景不同，因此要合理的使用索引类型。

    Hash索引(key-Value)
    
      不适用于对键(key)依赖于索引排序
      不适用于范围查找，使用 >,<等。键被作为Hash吗无法比较大小
    
    B+ Tree索引
* 4.是否使用合适的存储引擎，并有效利用了存储引擎的优势与特性

    &ensp;&ensp;读多写少(MyISAM)
    
    &ensp;&ensp;用到事务(InnoDB)
  
* 5.选用合适的锁策略(与存储引擎相关)
* 6.是否为InnoDB的缓冲池，MyISAM的键缓存以及MySQL查询缓存设定了合适大小的内存空间，以便能够存储频繁访问的数据且又不会引起页面换出

**操作系统及硬件级别的优化思路：**

* 1.是否为实际的工作负载选择了合适的CPU，如对于CPU密集型的应用场景要使用更快速的CPU甚至数量更多的CPU，为有着更多查询的场景使用更多的CPU等。

   实现CPU性能的提升有两类：低延迟和高吞吐量
   
      低延迟：使用更快速的CPU，因为单个查询只能使用一颗；
      高吞吐量：多查询，使用多颗CPU提高吞吐能力。
   注：MySQL的一个查询语句只能是一个CPU执行，无法拆分到多颗CPU执行。这也就是为什么在查询的时候建议使条简单的语句多次查询而不是通过复杂语句一次查询的原因。

* 2.是否有合适大小的物理内存。
* 3.是否选择合适的网络设备并配置合理的网络参数。延迟和带宽是网络连接的限制因素。
* 4.是否基于操作系统选择合适的文件系统
* 5.MySQl为响应每个用户连接使用一个单独的线程，在加上内部使用的线程、特殊目的线程以及其他任何由存储引擎创建的线程等。MySQL需要对这些大量线程进行有效的管理，有效的线程管理库可以提高MySQl性能。


### 索引

##### 聚集索引与非聚集索引

##### 主索引与辅助索引

##### 稠密索引与稀疏索引

&ensp;&ensp;每一种值得变化都有与之对应的索引条目，这种索引就叫做稠密索引。

&ensp;&ensp;并不是对每一种变化值都有与之对应的索引条目，这种索引就叫做稀疏索引。

&ensp;&ensp;主索引-->稠密索引  (不能稀疏索引)  辅助索引--> 可以稠密也可稀疏

&ensp;&ensp;聚集索引-->稠密索引


##### 多级索引

&ensp;&ensp;一级索引指向数据，二级索引指向一级索引，三级索引指向二级索引依次类推。目的是让索引方到内存中，完成查询。缺点是要进行三次IO(平均)操作才能完成数据定位。


### MySQL 索引

#### B+ Tree
&ensp;&ensp;B+ Tree 是多级索引。从根到每一个叶子结点的路径是等长的。对插入、删除方面影响比较小，是一种比较理想的索引类型。
##### 使用场景
* 1.适用全键值
* 2.键值范围
* 3.键左前缀查找

##### 局限性
* 1.不是从最左前缀开始，索引没用；如：like '%XXX%'
* 2.不能跳过索引中的列
* 3.存储引擎不能优化访问任何第一个范围条件右边的列


#### Hash索引
&ensp;&ensp;key — vlaue形式。键是指的Hash码，值(value)是数据所在位置。Hash索引不能为主索引。等值条件比较作为查询的时候使用。

##### 使用场景
* 1.只支持使用=，IN(),<=>进行条件比较

##### 缺陷
* 1.无法使用索引排序
* 2.不支持部分键匹配

#### 覆盖索引
&ensp;&ensp;数据查询在索引中完成，不用去访问数据。索引中包含要查询的字段，这种锁定叫做覆盖索引。覆盖索引是一种索引使用方法。

#### 空间索引

#### 全文索引
