### 内存结构中各个模块
&ensp;&ensp;内存区域中的各个模块按照是否线程之间共享可以分成两大块，比如线程私有的：程序计数器、虚拟机栈、本地方法栈；线程之间共享的：堆、方法区。
#### 程序计数器(Program Counter Register)
&ensp;&ensp;程序计数器是一块较小的内存空间，它可以看做当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

&ensp;&ensp;由于Java虚拟机的多线程是通过线程轮流切换并分配处理器这次能够时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条程序中的指令。因此，为了线程切换后能恢复到正确执行的位置，没条线程都需要有一个独立的程序计数器，各个线程之间计数器互补影响，独立存储。

&ensp;&ensp;线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器的值为Undefined。

#### 虚拟机栈(Java Virtual Machine Stacks)
&ensp;&ensp;在Java程序中，每个Java方法的执行都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法的调用直至执行完成的过程，就对应一个栈帧在虚拟机中从入栈到出栈的过程。它的生命周期与线程相同，也是线程私有的。

&ensp;&ensp;局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型,它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置)和return Address类型(指向一条字节码指令的地址)。

&ensp;&ensp;其中64位长度的long和double类型的数据会占用2个局部变量空间(Solt)，其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量表的空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

#### 本地方法栈(Native Method Stack)
&ensp;&ensp;本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法(字节码)服务，而本地方法栈则为虚拟机使用到的Native方法服务。

**总结：**

&ensp;&ensp; 上述的三个区域为线程私有的，我们知道线程私有，是不会存在线程安全问题的。

#### Java堆(Java Heap)
&ensp;&ensp;Java堆是Java虚拟机所管理的内存区域中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动的时候创建。该区域用来存放对象实例。

&ensp;&ensp;在Java虚拟机规范中描述：所有的对象实例以及数组都是在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变的不那么“绝对”了。

#### 方法区(Method Area)
&ensp;&ensp;方法区与Java堆一样，是各个线程之间共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

##### 运行时常量池(Runtime Constant Pool)
&ensp;&ensp;运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等信息之外，还有一项信息是常量池(Runtime Constant Pool)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载有进入方法去的运行时常量池中存放。

&ensp;&ensp;Java虚拟机对Class文件每一部分(包括常量池)的格式都有严格规定，每一个字节用于存储那种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有任何细节的要求，不同的提供商实现虚拟机可以按照自己的需要来实现这个区域。不过，一般来说，除了保存Class文件中描述的符号引用之外，还会把翻译出来的直接引用也存储在运行时常量池中。

&ensp;&ensp;运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运营时常量池，运行期间也可能将新的常量放入池中。
