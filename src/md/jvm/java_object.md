### Java 中的对象
&ensp;&ensp;在Java中我们创建对象的时候，都是通过new关键字来创建对象的。那么当虚拟机碰到new这个关键字的时候到底做了什么呢？上一篇文章中，对JVM的内存结构有了初步的认识，Java对象的创建是在堆中分配内存空间的(没有逃逸)。今天来了解一下对象的创建与内存布局。

#### 对象的创建
&ensp;&ensp;虚拟机遇到一条new指令的时候，首先将去检查这个指令的参与是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就必须要先执行相应的类加载过程。

&ensp;&ensp;类加载检查通过之后，接下来虚拟机将为新生对象分配内存。对象所需的内存在类加载完成之后就完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。

#### 内存布局
&ensp;&ensp;在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头(header)、实例数据(Instance Data)和对齐填充(Padding)。

##### 对象头
&ensp;&ensp;在HotSpot虚拟机的对象头中包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据官方称其为“Mark Word”。

&ensp;&ensp;对象的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。并不是所有的虚拟机实现都必须在数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。另外，如果是一个Java数组，那在对象头中必须还有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但从数组的元数据中却无法确定数组大小。

 ##### 实例数据
 &ensp;&ensp;实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段类容。无论是从父类中继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数(FieldsAllocationStyle)和字段在Java源码中定义顺序的影响。
 #### 对齐填充
 &ensp;&ensp;对齐填充并不是必然存在的，也没有特别的意义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象的起始位置必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数(1倍或2倍)，因此，当对象实例数据没对齐时，就需要通过对齐填充来补全。
 
 #### 对象的访问定位
 
 &ensp;&ensp;在JVM中，对象实例是在堆中创建，Java程序在运行的过程中需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中之规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以访问的方式也是取决于虚实机实现而定的。目前主流的访问方式有使用句柄和直接指针两种方式。
 
 * 如果使用句柄访问的话，那么Java堆中将会划分一块内存来作为句柄池，reference中存储的就是对象句柄的地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
 
 * 如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。
 
 
&ensp;&ensp;这两种访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象呗移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身就不需要修改。
 
&ensp;&ensp;使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。

&ensp;&ensp;在HotSpot虚拟主机中，使用直接指针访问。