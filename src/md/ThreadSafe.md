## :computer:1. 线程的生命周期

线程间状态转换：

![image](https://github.com/FunCheney/concurrency/blob/master/src/Image/2.png "Thread Status")
* 1.new 新建状态，线程被创建但未启动。创建线程的方式有以下几种：
    1. 继承Thread类
    2. 实现Runnable接口
    3. 实现Callable接口
    
       a. 可以通过call()获得返回值。
       
       b. call() 可以捕获异常。
* 2.ready-to-run 就绪状态 竞争cpu资源。线程调用start()方法之后的，运行之前的状态
* 3.Running 运行状态，run()方法正在执行的状态
* 4.Dead 死亡状态
* 5.Sleeping 睡眠状态 超时等待 当一定时间过了之后，重新竞争cpu资源
* 6.Waiting 等待状态，执行了wait()方法 需要唤醒 才可以竞争cpu资源
* 7.Blocked 阻塞状态

## 3. 线程安全
&ensp;&ensp;编写线程安全的代码，本质上就是管理对**状态**(state)的访问,而且通常是**共享的、可变的状态**。
* 1 一个对象的**状态**就是他的数据，存储在**状态变量**(state variables)中，比如实例域或静态域。对象的状态还包括了其他附属对象的域。
* 2 **共享**，是指一个变量可以被多个线程访问。
* 3 **可变**，是指变量的值在其生命周期内可以改变。

&ensp;&ensp;关于线程安全我们真正要做的，是在不可控制的并发访问中保护数据。一个对象是否应该是线程安全的取决于它是否会被多个线程访问。
线程安全的这个性质，取决于程序中如何使用对象。保证对象的线程安全性需要使用同步来协调其可变状态的访问；若做不到这一点，就会导致脏数据
和其他不可预期的后果。

&ensp;&ensp;当多个线程访问一个类时，如果不用考虑这些线程在运行时环境下的调度和交替执行，并且不需要额外的同步及在调用方代码
不必做其他的协调，这个类的行为仍然是正确的，那么称这个类是**线程安全的**。

## 4. Java中操作共享数据安全程度
(由强至若排序)

* 1.不可变

&ensp;&ensp;不可变(Immutable)的对象一定是线程安全的，无论是对象方法的实现者，还是方法调用者，都不需要采取任何
的线程安全保障措施。只要一个不可变对象被安全的构建出来，那么其外部的可见状态永远也不会改变，永远也不会看到他在多线程之中处于不一致
的状态。

&ensp;&ensp;如果共享数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，那么就需要
保证对象的行为不会对其状态产生任何影响才行。

&ensp;&ensp;Java中的String类的对象，它是一个典型的不可变对象，调用他的subString(),replace()和concat()这些方法都不会影响他原来的值，只会返回一
个新构造的字符串。

* 2.绝对线程安全

&ensp;&ensp;不管运行环境如何，调用者都不需要做任何额外的同步措施。
* 3.相对线程安全

&ensp;&ensp;相对线程安全就是我们通常意义上所讲的线程安全，它需要保证这个对象单独的操作时线程安全的，我们在调用的时候不需要做额外
的保障措施，但是对于一些特定顺序的连续操作，就可能需要在调用端使用额外的同步手段来保证调用的真确性。
* 4.线程兼容

&ensp;&ensp;线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端真确的使用同步手段来保证对象在并发环境下可以安全地使用，我们
平常说一个类不是线程安全的，绝大时候是指这一种情况。
* 5.线程对立

&ensp;&ensp;线程对立是指无论调用端是否采取了同步措施，都无法再多线程的环境中并发使用的代码。由于Java语言天生就具备多线程特性，线程对立这种
排斥多线程的代码时很少出现的，而且通常都是有害的，应当尽量避免。





 
 
